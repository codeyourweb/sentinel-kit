<?php

namespace App\Controller;

use App\Entity\Alert;
use App\Service\ElastalertSyncService;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Serializer\SerializerInterface;

/**
 * Alert Controller manages security alerts and rule-based detections.
 * 
 * This controller handles CRUD operations for security alerts generated by the Elastalert
 * integration. It provides endpoints for listing alerts, viewing alert details, getting
 * statistics, synchronizing alerts from Elasticsearch, and managing alerts by rule.
 */
#[Route('/api/alerts')]
class AlertController extends AbstractController
{
    private EntityManagerInterface $entityManager;
    private SerializerInterface $serializer;
    private ElastalertSyncService $elastalertSyncService;

    /**
     * Controller constructor with dependency injection.
     * 
     * @param EntityManagerInterface $entityManager Doctrine entity manager for database operations
     * @param SerializerInterface $serializer Symfony serializer for data transformation
     * @param ElastalertSyncService $elastalertSyncService Service for Elasticsearch alert synchronization
     */
    public function __construct(
        EntityManagerInterface $entityManager,
        SerializerInterface $serializer,
        ElastalertSyncService $elastalertSyncService
    ) {
        $this->entityManager = $entityManager;
        $this->serializer = $serializer;
        $this->elastalertSyncService = $elastalertSyncService;
    }

    /**
     * List alerts with pagination and filtering capabilities.
     * 
     * Retrieves a paginated list of security alerts with optional filtering by date range
     * or search terms. Supports both 'since' parameter for relative dates and absolute
     * date range filtering with 'startDate' and 'endDate' parameters.
     * 
     * @param Request $request HTTP request with query parameters
     * 
     * @return JsonResponse Paginated list of alerts with metadata
     * 
     * Query parameters:
     * - page: Page number for pagination (default: 1, min: 1)
     * - limit: Items per page (default: 20, min: 1, max: 100)
     * - since: Relative date filter (e.g., "-24 hours", "-1 week")
     * - startDate: Absolute start date (ISO format)
     * - endDate: Absolute end date (ISO format)
     * - filter: Text filter for rule title/description
     * 
     * Response format:
     * {
     *   "alerts": [
     *     {
     *       "id": number,
     *       "rule": {"id": number, "title": string, "description": string, "active": boolean},
     *       "rule_version": {"id": number, "level": string},
     *       "elastic_document_id": string,
     *       "event_timestamp": string,
     *       "created_at": string
     *     }
     *   ],
     *   "pagination": {"page": number, "limit": number, "total": number, "pages": number}
     * }
     */
    #[Route('', name: 'app_alerts_list', methods: ['GET'])]
    public function listAlerts(Request $request): JsonResponse
    {
        // Extract and validate pagination parameters
        $page = max(1, $request->query->getInt('page', 1));
        $limit = min(100, max(1, $request->query->getInt('limit', 20)));
        
        // Extract filter parameters
        $since = $request->query->get('since');
        $startDate = $request->query->get('startDate');
        $endDate = $request->query->get('endDate');
        $filter = $request->query->get('filter');
        
        // Build base query with joins for related entities
        $qb = $this->entityManager->getRepository(Alert::class)->createQueryBuilder('a')
            ->leftJoin('a.rule', 'r')
            ->leftJoin('a.sigmaRuleVersion', 'v')
            ->addSelect('r', 'v')
            ->orderBy('a.createdOn', 'DESC');

        $whereConditions = [];
        $parameters = [];

        // Apply date range filtering
        if ($startDate && $endDate) {
            try {
                $start = new \DateTime($startDate);
                $end = new \DateTime($endDate);
                $whereConditions[] = 'a.createdOn >= :startDate AND a.createdOn <= :endDate';
                $parameters['startDate'] = $start;
                $parameters['endDate'] = $end;
            } catch (\Exception $e) {
                return new JsonResponse(['error' => 'Invalid date format for startDate or endDate parameter'], Response::HTTP_BAD_REQUEST);
            }
        } elseif ($since) {
            try {
                $sinceDate = new \DateTime($since);
                $whereConditions[] = 'a.createdOn >= :since';
                $parameters['since'] = $sinceDate;
            } catch (\Exception $e) {
                return new JsonResponse(['error' => 'Invalid date format for since parameter'], Response::HTTP_BAD_REQUEST);
            }
        }

        // Apply text filter on rule title and description
        if ($filter && trim($filter)) {
            $whereConditions[] = '(r.title LIKE :filter OR r.description LIKE :filter)';
            $parameters['filter'] = '%' . trim($filter) . '%';
        }

        // Apply where conditions to query
        if (!empty($whereConditions)) {
            $qb->where(implode(' AND ', $whereConditions));
            foreach ($parameters as $key => $value) {
                $qb->setParameter($key, $value);
            }
        }

        // Apply pagination
        $offset = ($page - 1) * $limit;
        $qb->setFirstResult($offset)->setMaxResults($limit);

        $alerts = $qb->getQuery()->getResult();
        
        // Get total count for pagination metadata (with same filters)
        $totalQb = $this->entityManager->getRepository(Alert::class)->createQueryBuilder('a')
            ->select('COUNT(a.id)');
        
        if ($startDate && $endDate) {
            $start = new \DateTime($startDate);
            $end = new \DateTime($endDate);
            $totalQb->where('a.createdOn >= :startDate AND a.createdOn <= :endDate')
                    ->setParameter('startDate', $start)
                    ->setParameter('endDate', $end);
        } elseif ($since) {
            $sinceDate = new \DateTime($since);
            $totalQb->where('a.createdOn >= :since')
                    ->setParameter('since', $sinceDate);
        }
        
        $total = $totalQb->getQuery()->getSingleScalarResult();

        // Serialize alerts to standardized format
        $serializedAlerts = [];
        foreach ($alerts as $alert) {
            $serializedAlerts[] = [
                'id' => $alert->getId(),
                'rule' => [
                    'id' => $alert->getRule()->getId(),
                    'title' => $alert->getRule()->getTitle(),
                    'description' => $alert->getRule()->getDescription(),
                    'active' => $alert->getRule()->isActive()
                ],
                'rule_version' => [
                    'id' => $alert->getSigmaRuleVersion()->getId(),
                    'level' => $alert->getSigmaRuleVersion()->getLevel()
                ],
                'elastic_document_id' => $alert->getElasticDocument(),
                'event_timestamp' => $alert->getEventCreatedAt()?->format('c'),
                'created_at' => $alert->getCreatedOn()->format('c')
            ];
        }

        return new JsonResponse([
            'alerts' => $serializedAlerts,
            'pagination' => [
                'page' => $page,
                'limit' => $limit,
                'total' => (int)$total,
                'pages' => (int)ceil($total / $limit)
            ]
        ]);
    }

    /**
     * Get detailed information for a specific alert.
     * 
     * Retrieves complete details for a single alert including rule information,
     * rule version details, and associated event metadata.
     * 
     * @param int $id Alert ID to retrieve
     * 
     * @return JsonResponse Complete alert details or error message
     * 
     * Success response (200):
     * {
     *   "id": number,
     *   "rule": {"id": number, "title": string, "description": string, "active": boolean, "filename": string},
     *   "rule_version": {"id": number, "level": string, "content": string, "created_at": string},
     *   "elastic_document_id": string,
     *   "event_timestamp": string,
     *   "created_at": string
     * }
     * 
     * Error response (404): {"error": "Alert not found"}
     */
    #[Route('/{id}', name: 'app_alert_details', methods: ['GET'])]
    public function getAlert(int $id): JsonResponse
    {
        // Find the alert by ID
        $alert = $this->entityManager->getRepository(Alert::class)->find($id);
        
        if (!$alert) {
            return new JsonResponse(['error' => 'Alert not found'], Response::HTTP_NOT_FOUND);
        }

        // Build comprehensive alert data structure
        $alertData = [
            'id' => $alert->getId(),
            'rule' => [
                'id' => $alert->getRule()->getId(),
                'title' => $alert->getRule()->getTitle(),
                'description' => $alert->getRule()->getDescription(),
                'active' => $alert->getRule()->isActive(),
                'filename' => $alert->getRule()->getFilename()
            ],
            'rule_version' => [
                'id' => $alert->getSigmaRuleVersion()->getId(),
                'level' => $alert->getSigmaRuleVersion()->getLevel(),
                'content' => $alert->getSigmaRuleVersion()->getContent(),
                'created_at' => $alert->getSigmaRuleVersion()->getCreatedOn()->format('c')
            ],
            'elastic_document_id' => $alert->getElasticDocument(),
            'event_timestamp' => $alert->getEventCreatedAt()?->format('c'),
            'created_at' => $alert->getCreatedOn()->format('c')
        ];

        return new JsonResponse($alertData);
    }

    /**
     * Get alert statistics and metrics.
     * 
     * Retrieves aggregated statistics about alerts for monitoring and dashboard purposes.
     * Supports time-based filtering to get statistics for specific periods.
     * 
     * @param Request $request HTTP request with optional query parameters
     * 
     * @return JsonResponse Alert statistics or error message
     * 
     * Query parameters:
     * - since: Time period for statistics (default: "-24 hours")
     * 
     * Response format varies based on ElastalertSyncService implementation
     */
    #[Route('/stats', name: 'app_alerts_stats', methods: ['GET'])]
    public function getAlertsStats(Request $request): JsonResponse
    {
        $since = $request->query->get('since', '-24 hours');
        
        try {
            $sinceDate = new \DateTime($since);
            $stats = $this->elastalertSyncService->getAlertStats($sinceDate);
            
            return new JsonResponse($stats);
        } catch (\Exception $e) {
            return new JsonResponse(['error' => 'Invalid date format: ' . $e->getMessage()], Response::HTTP_BAD_REQUEST);
        }
    }

    /**
     * Synchronize alerts from Elasticsearch/Elastalert.
     * 
     * Triggers synchronization of alerts from the Elasticsearch backend,
     * importing new alerts that have been generated since the specified time.
     * 
     * @param Request $request HTTP request with sync parameters
     * 
     * @return JsonResponse Synchronization results or error message
     * 
     * Request body (optional):
     * {
     *   "since": string  // Time period to sync from (default: "-1 hour")
     * }
     * 
     * Success response (200):
     * {
     *   "message": "Synchronization completed",
     *   "stats": object  // Sync statistics from ElastalertSyncService
     * }
     */
    #[Route('/sync', name: 'app_alerts_sync', methods: ['POST'])]
    public function syncAlerts(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true) ?? [];
        $since = $data['since'] ?? '-1 hour';
        
        try {
            $sinceDate = new \DateTime($since);
            $stats = $this->elastalertSyncService->syncElastalertAlerts($sinceDate);
            
            return new JsonResponse([
                'message' => 'Synchronization completed',
                'stats' => $stats
            ]);
        } catch (\Exception $e) {
            return new JsonResponse([
                'error' => 'Synchronization failed: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Get alerts associated with a specific Sigma rule.
     * 
     * Retrieves a paginated list of alerts that were triggered by a specific
     * Sigma rule, useful for rule-based analysis and debugging.
     * 
     * @param int $ruleId Sigma rule ID to get alerts for
     * @param Request $request HTTP request with pagination parameters
     * 
     * @return JsonResponse Paginated alerts for the rule or error message
     * 
     * Query parameters:
     * - page: Page number (default: 1)
     * - limit: Items per page (default: 20, max: 100)
     * 
     * Error response (404): {"error": "Rule not found"}
     */
    #[Route('/rules/{ruleId}/alerts', name: 'app_rule_alerts', methods: ['GET'])]
    public function getAlertsForRule(int $ruleId, Request $request): JsonResponse
    {
        $rule = $this->entityManager->getRepository(\App\Entity\SigmaRule::class)->find($ruleId);
        
        if (!$rule) {
            return new JsonResponse(['error' => 'Rule not found'], Response::HTTP_NOT_FOUND);
        }

        $page = max(1, $request->query->getInt('page', 1));
        $limit = min(100, max(1, $request->query->getInt('limit', 20)));
        
        $qb = $this->entityManager->getRepository(Alert::class)->createQueryBuilder('a')
            ->leftJoin('a.sigmaRuleVersion', 'v')
            ->addSelect('v')
            ->where('a.rule = :rule')
            ->setParameter('rule', $rule)
            ->orderBy('a.createdOn', 'DESC');

        $offset = ($page - 1) * $limit;
        $qb->setFirstResult($offset)->setMaxResults($limit);

        $alerts = $qb->getQuery()->getResult();
        
        $totalQb = $this->entityManager->getRepository(Alert::class)->createQueryBuilder('a')
            ->select('COUNT(a.id)')
            ->where('a.rule = :rule')
            ->setParameter('rule', $rule);
        
        $total = $totalQb->getQuery()->getSingleScalarResult();

        $serializedAlerts = [];
        foreach ($alerts as $alert) {
            $serializedAlerts[] = [
                'id' => $alert->getId(),
                'elastic_document_id' => $alert->getElasticDocument(),
                'event_timestamp' => $alert->getEventCreatedAt()?->format('c'),
                'created_at' => $alert->getCreatedOn()->format('c'),
                'rule_version' => [
                    'id' => $alert->getSigmaRuleVersion()->getId(),
                    'level' => $alert->getSigmaRuleVersion()->getLevel()
                ]
            ];
        }

        return new JsonResponse([
            'rule' => [
                'id' => $rule->getId(),
                'title' => $rule->getTitle()
            ],
            'alerts' => $serializedAlerts,
            'pagination' => [
                'page' => $page,
                'limit' => $limit,
                'total' => (int)$total,
                'pages' => (int)ceil($total / $limit)
            ]
        ]);
    }
    
    /**
     * Test Elasticsearch connectivity and status.
     * 
     * Performs a connectivity test to the Elasticsearch backend to verify
     * the alert synchronization system is functioning properly.
     * 
     * @return JsonResponse Connection status and basic statistics
     * 
     * Success response (200):
     * {
     *   "status": "success",
     *   "message": "Elasticsearch connection successful",
     *   "elasticsearch_status": object
     * }
     * 
     * Error response (500):
     * {
     *   "status": "error",
     *   "message": "Elasticsearch connection error", 
     *   "error": string
     * }
     */
    #[Route('/test/elasticsearch', name: 'alerts_test_elasticsearch', methods: ['GET'])]
    public function testElasticsearch(): JsonResponse
    {
        try {
            $stats = $this->elastalertSyncService->getAlertStats();
            
            return new JsonResponse([
                'status' => 'success',
                'message' => 'Elasticsearch connection successful',
                'elasticsearch_status' => $stats
            ]);
            
        } catch (\Exception $e) {
            return new JsonResponse([
                'status' => 'error',
                'message' => 'Elasticsearch connection error',
                'error' => $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
}